# Recordar:
+ Si ECX vale 0, la instrucción adc $0,%ecx pone CF a 0

+ Dada la siguiente definición de datos:
~~~
lista: .int 0x10000000, 0x50000000, 0x10000000, 0x20000000
longlista: .int (.-lista)/4
resultado: .quad 0x123456789ABCDEF
formato: .ascii "suma=%llu=%llx hex\n\0"
~~~
La instrucción para copiar la dirección de memoria donde comienza lista en el registro EBX es movl $lista, (%ebx)

+ `mov longsaludo, %edx`mueve el **valor** de la variable “longsaludo” al registro “edx”

+ `mov $saludo, %ecx` mueve la **dirección** de la variable “saludo” al registro “ecx”

+  ¿Qué sucede si se elimina el símbolo de dato inmediato ($) de la instrucción anterior? (mov saludo, %ecx) Si se elimina el símbolo de dato inmediato ($), en vez de mover la dirección de memoria de “saludo” al registro “ecx”, lo que haremos será mover el contenido de saludo al registro.

+ ¿Cuál de las siguientes instrucciones máquina copia en EAX la dirección efectiva resultante de la operación EDX\*4 + EBX? **leal (%ebx, %edx, 4), %eax**

+ ¿Cuál de las siguientes instrucciones máquina copia en EAX el entero
almacenado en la posición de memoria cuya dirección efectiva es el resultado de la operación EDX\*4 + EBX? **movl (%ebx, %edx, 4), %eax**

+ Si ECX vale 0, la instrucción adc $0,%ecx pone CF=0

+ La instrucción para copiar la dirección de memoria donde comienza lista en el registro EBX es: **movl $lista, %ebx**

+ Dada la siguiente definición de datos:
~~~
lista:
.int 0x10000000, 0x50000000,
0x10000000, 0x20000000
longlista:
.int (.-lista)/4
resultado:
.quad 0x123456789ABCDEF
formato: .ascii "suma=%llu=%llx hex\n\0"
~~~
la instrucción `movl longlista, %ecx`, copia el siguiente valor: **4**

+ Dada la siguiente definición de datos:
~~~
lista:
.int 0x10000000, 0x50000000,
0x10000000, 0x20000000
longlista:
.int (.-lista)/4
resultado:
.quad 0x123456789ABCDEF
formato: .ascii "suma=%llu=%llx hex\n\0"
~~~
y suponiendo que hemos llamado a una función suma que devuelve un número de 64 bits en la pareja EDX:EAX, las instrucciones que copian ese número en resultado son:
~~~
movl %eax, resultado
movl %edx, resultado+4
~~~

+ Dada la siguiente definición de datos:
~~~
lista:
.int 0x10000000, 0x50000000,
0x10000000, 0x20000000
longlista:
.int (.-lista)/4
resultado:
.quad 0x123456789ABCDEF
formato: .ascii "suma=%llu=%llx hex\n\0"
~~~
la llamada correcta a printf será:
~~~
push resultado+4
push resultado
push resultado+4
push resultado
push $formato
call printf
add $20, %esp
~~~

+ En la práctica “media” se pide sumar una lista de enteros *con* signo de 32 bits en una plataforma de 32 bits sin perder precisión, esto es, evitando overflow. ¿Cuál es el menor valor positivo que repetido en los *dos* primeros elementos de la lista causaría overflow con 32 bits al realizar la suma de *esos dos* primeros elementos de la lista?**0x4000 0000**

+ En lenguaje C, al llamar a una subrutina o función se introducen los parámetros en la pila y después se realiza una llamada a la subrutina.

+ Afirmaciones falsas con respecto al lenguaje C: Los parámetros se introducen en la pila en el orden en el que aparecen en la llamada de C, es decir, empezando por el primero y acabando por el
último. Antes de volver de la rutina llamada, el programa en C se encarga de quitar de la pila los parámetros de llamada realizando varios pop. Pasar a una función un puntero a una variable se traduce en introducir en la pila el valor de la variable.

+ ¿Cuál de los siguientes registros tiene que ser salvaguardado (si va a modificarse) dentro de una subrutina según la convención cdecl para IA32? **ebx**, no %eax ni %ecx ni %edx.

>x86 registers

>There are 9 registers in x86: EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP and EIP. These are mostly derived by prefixing E(Extended) to their 16 bit equivalents.

>EAX: The accumulator. This register typically stores return values from functions.

>EBX: This register is typically the pointer to the base of an array.

>ECX: This is typically used as a counter: loops, iterating through an array etc.

>EDX: Commonly used as a supporting register. For example, 64 bit return values are returned in EDX:EAX in the code generated by 32 bit compilers.

>ESI: The source index for string operations.

>EDI: The destination index for string operations.

>EBP: This register points to the base of the current function’s stack frame.

>ESP: This register points to the top of the current function’s stack frame.

>EIP: This register points to the address of the next instruction. This is the only instruction that cannot be manipulated by any instruction except call and ret.

>x86 register conventions

>Caller save registers: These registers have to be saved by the caller function if it wants to preserve their values. EAX, ECX and EDX are caller save registers. EAX is usually modified by the callee in almost all cases(it holds the return value remember?)

>Callee save register: These registers have to be saved by callee function if it will modify these registers. EBP, EBX, EDI and ESI are callee save registers. EBP is usually modified by the callee in almost all cases(it points to the base of the function’s stack frame remember?)

>Calling conventions

>There are multiple ways to pass the parameters to the callee function. Here I will discuss 3 such conventions.

>1. CDECL convention: C Declaration. In this convention, the parameters are passed in the reverse order(i.e. from right to left) on the stack by the caller and the caller is responsible for cleaning up the parameters from the stack i.e. it is caller clean up. GCC follows this convention. I think even MS Visual Studio does-at least the free Express edition.

>2. STDCALL convention: Standard Call. This is exactly same as CDECL except that the callee is responsible for removing the parameters from the stack i.e. it is callee clean up. The Win32 API follows this convention.

>3. FASTCALL convention: I have never encountered this convention before but the idea is that some parameters are passed through the registers and rest through the stack. There is no universal standard-each compiler designer has a different implementation of the convention. This is also callee clean up.

+ ¿En qué registro se pasa el primer argumento a una función en Linux gcc x86-64? **%%edi**, no %ecx ni %edx ni %esi

+ La práctica "popcount" debía calcular la suma de bits (peso Hamming) de los elementos de un array. Un estudiante entrega la siguiente versión de popcount3:


Esta función produce siempre el resultado correcto, a pesar de que una instrucción máquina en la sección asm() es distinta a la que se esperaba después de haber estudiado pcount_r en teoría. La instrucción distinta también se podría haber cambiado
por... **test %[x], %[x]**, no sar %[x], adc $0, %[x],cmp %[x], %[r]

~~~c
int popcount3(unsigned* array,int len){
  int i, res = 0;

  unsigned x;

  for( i=0; i<len; i++ ) {
    x = array[i];
    asm("ini3:\n"
    "shr %[x]\n"
    "adc $0, %[r]\n"
    "add $0, %[x]\n"
    "jne ini3\n"
    : [r] "+r" (res)
    : [x] "r" (x) );
  }
  return res;
}
~~~
>The shr or sar instruction is used to shift the bits of the operand destination to the right, by the number of bits specified in the count operand.
Bits shifted beyond the destination are first shifted into the CF flag.
Equivalent to dividing by 2^3. shr fills with zeroes, and sar fills with the sign bit.

+ En la práctica de la bomba necesitamos estudiar el código máquina de la bomba del compañero. A veces dicho código no se visualiza directamente en el depurador ddd, y algunas de las técnicas que se pueden probar para conseguir visualizarlo son... (marcar la opción *falsa*)
a. comprobar que está activado el panel View → Machine Code Window
b. escribir info line main en el panel de línea de comandos gdb
**c. recompilar con información de depuración, por si se nos había olvidado, ya que sin –g el ejecutable no contiene información de depuración**
d. asegurarse de que se ha escrito correctamente el nombre del ejecutable

+ En la práctica de la bomba, el primer ejercicio consistía en “saltarse” las “explosiones”, para lo cual se puede utilizar... **gdb o ddd**, poniendo breakpoints.

+ En la práctica de la bomba, el segundo ejercicio consistía en crear un ejecutable sin “explosiones”, para lo cual se puede utilizar... **gdb o ddd, ddd o hexedit**

+ En la práctica de la bomba, el tercer ejercicio consistía en usar un editor hexadecimal para crear un ejecutable sin “explosiones”. Para saber qué contenidos del fichero hay que modificar, se puede utilizar... (marcar la opción falsa): objdump, gdb, ddd, **hexedit**

+ Suponer una memoria cache con las siguientes propiedades: Tamaño: 512 bytes. Política de reemplazo: LRU. Estado inicial: vacía (todas las líneas inválidas). Suponer que para la siguiente secuencia de direcciones enviadas a la cache: 0, 2, 4, 8, 16, 32, la tasa de acierto es 0,33. ¿Cuál es el tamaño de bloque de la cache? 4 bytes, **8 bytes**, 16 bytes, Ninguno de los anteriores.

+ Abajo se ofrece el listado de una función para multiplicar matrices C = A x B.El computador tiene una cache de datos de 8 MB, 16-vías, líneas de 64 bytes. N es grande, una fila o columna no cabe completa en cache. El tamaño de los tipos de datos es como en IA32. El compilador optimiza el acceso a C[i][j] en un registro. Aproximadamente, ¿qué tasa de fallos se podría esperar de esta función para valores grandes de N? **1/2**, 1/4, 1/8, 1/16
>Tasa de fallos= MB de la cache de datos/vías

+ Sea un computador de 32 bits con una memoria cache L1 para datos de 32 KB y líneas de 64 bytes asociativa por conjuntos de 2 vías. Dado el siguiente fragmento de código:
~~~c
int v[262144];
for (i=0; i<262144; i+=8)
v[i] = 9;
~~~
¿Cuál será la tasa de fallos aproximada que se obtiene en la ejecución del bucle anterior?
0 (ningún fallo), **1/2 (mitad aciertos, mitad fallos)**, 1/8 (un fallo por cada 8 accesos), 1 (todo son fallos)
> 1/número de vías? datos/líneas?
